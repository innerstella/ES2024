### strict mode

자바스크립트 언어의 문법을 좀 더 엄격히 적용하여 오류를 발생시킬 가능성이 높거나 자스 엔진의 최적화 작업에 문제를 일으킬 수 있는 코드에 대해 명시적인 에러를 발생시킴

- ESLint 같은 린트 도구를 사용해도 strict mode와 유사한 효과를 얻을 수 있음
  - 린트 도구 : 정적 분석 기능을 통해 소스코드를 실행하기 전에 소스코드를 스캔하여 문법적 오류만이 아니라 잠재적 오류까지 찾아내고 오류의 원인을 리포팅해주는 유용한 도구

### 전역에 strict mode를 적용하는 것은 피하자

- 전역에 적용한 strict mode는 스크립트 단위로 적용된다.
- 스크립트 단위로 적용된 strict mode는 다른 스크립트에 영향을 주지 않고 해당 스크립트에 한정되어 적용된다.
- 하지만 strict mode 스크립트와 non-strict mode 스크립트를 혼용하는 것은 오류를 발생시킬 수 있다
  - 특히 외부 서드파티 라이브러리는 non-strict mode인 경우도 있다
  - 이런 경우 즉시 실행 함수로 스크립트 전체를 감싸서 스코프를 구분하고 즉시 실행 함수의 선두에 strict mode를 적용한다

### 함수 단위로 strict mode를 적용하는 것도 피하자

즉시 실행함수로 감싼 스크립트 단위로 적용하는 것이 바람직함

### strict mode가 발생시키는 에러

- 암묵적 전역
  - 선언하지 않은 변수를 참조하면 ReferenceError가 발생함
- 변수, 함수, 매개변수의 삭제
  - delete 연산자로 변수, 함수, 매개변수를 삭제하면 SyntaxError가 발생함
- 매개변수 이름의 중복
  - 중복된 매개변수 이름을 사용하면 SyntaxError가 발생함
- with 문의 사용
  - syntaxError

### strict mode 적용에 의한 변화

- 일반 함수의 this
  - undefined 바인딩 (원래는 전역 객체 window)
- arguments 객체
  - 매개변수에 전달된 인수를 재할당하여 변경해도 arguments 객체에 반영되지 않는다

<aside>
❓ 암묵적 전역 (implicit global)

- 전역 스코프에도 x 변수의 선언이 존재하지 않을 때, 자스 엔진이 암묵적으로 전역 객체에 x 프로퍼티를 동적 생성한다. 이 때 전역 객체의 x 프로퍼티는 마치 전역 변수처럼 사용할 수 있다.
- 하지만 개발자의 의도와는 상관없이 발생한 암묵적 전역은 오류를 발생시키는 원인이 될 가능성이 크다.
- 따라서 반드시 var, let, const 키워드를 사용하여 변수를 선언한 다음 사용해야 한다.
</aside>

String("a")을 "new"키워드 없이 호출했을 때, 이 String()은 생성자 함수일까?

생성자 함수는 일반적으로 호출될 대마다 새로운 인스턴스를 생성한다.
Math, reflect, JSON을 제외한 모든 빌트인 객체는 모두 인스턴스를 생성할 수 있는 생성자 함수 객체이다.
따라서 String()은 생성자 함수로 호출하여 인스턴스를 생성할 수 있다. 하지만 "new"키워드 없이 String("a")을 호출한 경우 typeof(String("a"))의 결과는 string이므로 객체 즉 인스턴스를 생성하지 않았다. 그렇다면 이 String()은 생성자 함수가 아닐까? 사실 String("a")는 인스턴스를 생성한다.

1. String("a")에서 "a"는 이미 문자열이지만 래퍼 객체인 String 인스턴스로 변환된다.
2. "a"는 이미 문자열이지만, "a"를 가능하다면 string타입으로 바꾼다.
3. 다시 "a"를 원시 값으로 되돌린다.
   결론적으로는 JavaScript에서 기본 데이터 타입을 각각의 래퍼 객체로 감싸는 것과 관련이 있다.

빌트인 객체를 생성할때 "new" 키워드를 사용하는것과 사용하지 않는 것의 차이점.

<aside> 
`String("str"), new String("str")`
`Object("obj"), new Object("obj")`
</aside>

String("str")은 위에서 설명했듯 래퍼 객체 String()의 인스턴스로 변환되고, 다시 "str"이라는 원시 값으로 되돌린다.
new String("str")은 래퍼 객체인 String()의 인스턴스인 [String: "str"]이라는 래퍼 객체가 생성된다. 이는 유사 객체다.
Wrapper 객체는 원시 데이터 타입을 객체처럼 다룰 수 있도록 해주지만, 실제로는 원시 데이터 타입과는 별도의 타입이다.
Object("obj")와 new Object("obj")는 실제로 동일한 결과를 생성한다. 이 둘은 모두 문자열 "a"를 값으로 가지는 문자열 객체를 생성하게 된다. Object() 함수는 인자로 전달된 값을 해당 타입의 객체로 변환하는 역할을 한다. 이때 인자가 이미 객체인 경우 그대로 반환하고, 원시 타입인 경우 Wrapper 객체로 변환한다.
new Object()의 경우 위 new String()과 같다.

다음 코드의 결과는 무엇일까? 그리고 그 이유는?

```javascript
const a = new String("a");
const b = Object("b");

console.log(a === b);
```

서로 다른 객체를 참조하기 때문에
위의 코드에서 valueOf()나 toString() 메서드를 호출하여 각 객체를 해당하는 원시 값으로 변환한 후, 그 값을 비교하면 결과가 같다.

Person이라는 생성자 함수가 있다고 가정할때, new Create(1, 2)로 호출하는것과 Create(1, 2)로 호출하는것의 차이는?

```javascript
function Person(name, age) {
  this.name = name;
  this.age = age;
}
```

생성자 함수가 호출되면 내부에서는 새로운 객체를 생성하고, this를 통해 속성을 설정합니다. 그러나 new 키워드를 사용하지 않고 호출되었기 때문에, 이 함수는 일반 함수처럼 동작하게 된다.
생성자 함수가 명시적으로 반환값을 지정하지 않았으므로, 반환값이 없는 경우 undefined를 반환.
그렇다면 Object(1, 2)는 undefined가 반환되지 않고 [Number: 1]이 반환되는 이유는 Object 함수는 전달된 인수를 객체로 변환하는 역할을 한다. 이 때에는 생성자 함수로 사용된다. 인수로 전달된 값인 1은 숫자다. Object 함수는 이를 원시 값으로 감싸서 해당 원시 값의 Wrapper 객체를 생성한다. 따라서 Object(1, 2)는 Number 원시 값인 1을 감싼 숫자 객체인 [Number: 1]을 생성하게 된다.
