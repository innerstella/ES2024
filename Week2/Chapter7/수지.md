# 7.1 산술 연산자

- 피연산자를 대상으로 수학적 계산을 수행해 새로운 숫자 값을 만듦
- 산술 연산이 불가능한 경우, NaN 반환

## 7.1.1 이항 산술 연산자

| 이항 산술 연산자 | 의미   | 부수 효과 |
| ---------------- | ------ | --------- |
| +                | 덧셈   | x         |
| -                | 뺄셈   | x         |
| \*               | 곱셈   | x         |
| /                | 나눗셈 | x         |
| %                | 나머지 | x         |

- 모든 이항 산술 연산자는 피연산자의 값을 변경하는 side effect 없음
  → 어떤 산술 연산을 해도, 언제나 새로운 값을 만든다

```jsx
5 + 2; // -> 7
```

## 7.1.2 단항 산술 연산자

| 단항 산술 연산자 | 의미                       | 부수 효과 |
| ---------------- | -------------------------- | --------- |
| ++               | 증가                       | o         |
| —                | 감소                       | o         |
| +                | 효과 없음. 음 양 반전 없음 | x         |
| -                | 음↔양 반전                 | x         |

- 증가/감소 연산자는 피연산자의 값을 변경하는 side effect 존재
  → 피연산자의 값을 변경하는 암묵적 할당이 이뤄짐
- 증가/감소 연산자의 위치에 따라,
  - 전위 : 선할당 후연산
  - 후위 : 선연산 후할당
  ```jsx
  var x = 5,
    result;

  // 전위 : 선할당 후증가
  result = x++;
  console.log(result, x); // 5 6

  // 후위 : 선증가 후할당
  result = ++x;
  console.log(result, x); // 7 7
  ```
- 숫자 타입이 아닌 피연산자에 + → 피연산자를 숫자 타입으로 변환하여 반환

## 7.1.3 문자열 연결 연산자

- - 연산자는 피연산자 중 하나 이상이 문자열인 경우, 문자열 연결 연산자로 동작한다
    - 개발자의 의도와는 상관 없이 자바스크립트 엔진에 의해 암묵적으로 타입이 자동 변환되기도 함
      ⇒ 암묵적 타입 변환 (타입 강제 변환)

# 7.2 할당 연산자

- 우항에 있는 피연산자의 평가 결과를 좌항에 있는 변수에 할당함
- side effect 존재함

<aside>
❓ 할당문은 표현식인 문일까?

```jsx
var x;

console.log((x = 10)); // 10
```

할당문은 값으로 평가되는 표현식인 문으로서, 할당된 값으로 평가된다.

</aside>

# 7.3 비교 연산자

- 좌항과 우항의 피연산자 비교 → boolean return
- 제어문의 조건식에서 주로 사용됨

## 7.3.1 동등/일치 비교 연산자

- 좌항과 우항의 피연산자가 같은 값으로 평가되는 지 비교 → boolean return
- 엄격성의 정도가 다름
  - 동등 : 느슨한 비교 → 암묵적 타입 변환을 통해 타입을 일치시킨 후 같은 값인지 비교
    - 암묵적 타입 변환 : 개발자의 의도와는 상관없이 자스 엔진에 의해 암묵적으로 타입이 자동 변환되는 것
    - 결과를 예측하기 어렵고 실수하기 쉽다
    - 사용하지 않는 편이 좋다
  - 일치 : 엄격한 비교 (타입까지 비교)
    - 예측하기 쉽다
    - 주의할 점 : NaN
      - NaN은 자신과 일치하지 않는 유일한 값이기 때문에, 숫자가 NaN인지 확인하려면, `Number.isNaN` 을 사용한다
- `Object.is`
  - 예측 가능한 정확한 비교 결과를 반환함
    ```jsx
    -0 === +0; // true
    Object.is(-0, +0); // false
    ```

## 7.3.2 대소 관계 비교 연산자

- 피연산자의 크기 비교 → boolean return

# 7.4 삼항 조건 연산자

- 조건식의 평가 결과에 따라 반환할 값 결정
- side effect 없음

```
조건식 ? 조건식이 true일 때 반환할 값 : 조건식이 false일 때 반환할 값
```

<aside>
❓ if …else문과 삼항 조건 연산자 표현식의 차이?

- 삼항 조건 연산자 표현식 : 값처럼 사용 가능
- if …else 문 : 갑서럼 사용 불가능

⇒ 삼항 조건 연산자 표현식은 값으로 평가할 수 있는 표현식인 문이다

⇒ 값처럼 다른 표현식의 일부가 될 수 있어 매우 유용함

</aside>

# 7.5 논리 연산자

- 우항과 좌항의 피연산자를 논리 연산
- 부수 효과 없음
- &&, ||, !

# 7.6 쉼표 연산자

- 왼쪽 피연산자부터 차례대로 피연산자를 평가하고 마지막 피연산자의 평가가 끝나면 마지막 피연산자의 평가 결과를 반환함

```jsx
var x, y, z;

(x = 1), (y = 2), (z = 3); // 3
```

# 7.7 그룹 연산자

- ()
- 자신의 피연산자인 표현식을 가장 먼저 평가함
- 연산자의 우선순위 조절 가능 (가장 높음)

# 7.8 typeof 연산자

- 피연산자의 데이터 타입을 문자열로 반환
  - string, number, boolean, undefined, symbol, object, function
- typeof 연산자가 반환하는 문자열은 7개의 데이터 타입과 정확히 일치하지는 않음
- null은 반환되지 않기 때문에 (object로 반환됨), 값이 null인지 확인하려면 일치 연산자 사용 권장
- 선언하지 않은 식별자 → undefined

# 7.9 지수 연산자

- es7 도입
- 좌항의 피연산자 → 밑
- 우항의 피연산자 → 지수

# 7.10 그 외의 연산자

- ?. : 옵셔널 체이닝 연산자
- ?? : null 병합 연산자
- delete : 프로퍼티 삭제
- new : 생성자 함수를 호출할 때 사용하여 인스턴스를 생성
- instanceof : 좌변의 객체가 우변의 생성자 함수와 연결된 인스턴스인지 판별
- in : 프로퍼티 존재 확인

# 7.11 연산자의 부수 효과

- 대부분 연산자는 다른 코드에 영향을 주지 않음
- 부수 효과가 있는 연산자
  - 할당 연산자 (=)
  - 증가/감소 연산자 (++/—)
  - delete 연산자

# 7.12 연산자 우선순위

- 우선순위가 높을수록 먼저 실행됨
- 기억에 의존하기보다는, 연산자 우선순위가 가장 높은 그룹 연산자를 사용하여 우선순위를 명시적으로 저절하는 것 권장

# 7.13 연산자 결합 순서

- 연산자의 어느쪽부터 평가를 수행할 것인지 나타내는 순서
  | 결합 순서 | 연산자 |
  | --- | --- |
  | 좌항 → 우항 | +, -, /, %, <, <=, >, >=, &&, ||, ., [], (), ??, ?., in, instanceof |
  | 우항 → 좌항 | ++, —, 할당 연산자, !x, +x, -x, ++x, —x, typeof, delete, ? … : >>>, \*\* |
