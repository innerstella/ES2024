def) 함수와 그 함수가 선언된 렉시컬 환경과의 조합

- 내부에서 정의된 중첩 함수는 외부 스코프의 변수에 접근 가능
  - 왜냐하면, 자바스크립트는 렉시컬 스코프를 따르는 프로그래밍 언어

# 24.1 렉시컬 스코프

def) 함수를 어디에서 정의했는지에 따라 상위 스코프 결정

- 함수의 상위 스코프를 결정한다
  - 렉시컬 환경의 외부 렉시컬 환경에 대한 참조에 저장할 참조 값을 결정한다
    - 상위 렉시컬 환경에 대한 참조 (상위 스코프)
  - 상위 스코프에 대한 참조는, 함수 정의가 평가되는 시점에 함수가 정의된 환경(위치)에 의해 결정됨
    - 렉시컬 스코프
- lexical
  - 코드의 syntax, sematics
  - 문맥에 따른 단어나 구문의 의미

# 24.2 함수 객체의 내부 슬롯 [Environment]

- 함수가 정의된 환경 ≠ 함수가 호출되는 환경
- 렉시컬 스코프 → 상위 스코프 기억 필요 (정의된 환경)
  - 함수 자신의 내부 슬롯에 자신이 정의된 환경(상위 스코프) 저장함
- 상위 스코프
  - 현재 실행 중인 실행 컨텍스트의 렉시컬 환경
  - 상위 함수의 실행 컨텍스트
- 전역에서 정의된 함수 선언문
  - 전역 코드가 평가되는 시점에 평가되어 함수 객체 생성
  - 내부 슬롯에는 이 시점의 실행 컨텍스트의 렉시컬 환경의 참조가 정의됨

<aside>
💡 상위 스코프

- 현재 실행 중인 실행 컨텍스트의 렉시컬 환경의 참조
</aside>

- 함수 객체는 내부 슬롯에 저장한 상위 스코프를 자신이 존재하는 한 기억함

- 함수 코드 평가 순서
  1. 함수 호출
  2. 함수 실행 컨텍스트 생성
  3. 함수 렉시컬 환경 생성
     1. 함수 환경 레코드 생성
     2. this 바인딩
     3. 외부 렉시컬 환경에 대한 참조 결정

# 24.3 클로저와 렉시컬 환경

- 클로저
  - 외부 함수보다 중첩 함수가 더 오래 유지되는 경우, 중첩 함수는 이미 생명 주기가 종료한 외부 함수의 변수 참조 가능
  - 함수와 그 함수가 선언된 렉시컬 환경과의 조합
- 상위 스코프의 여러 식별자 중 일부만 참조하고 있다면, 그것만 기억함
- 자유 변수
  - 클로저에 의해 참조되는 상위 스코프의 변수
- 자바스크립트의 모든 함수는 자신의 상위 스코프를 기억함 (내부 슬롯)
  - 함수를 어디에서 호출하든 함수는 언제나 자신이 기억하는 상위 스코프에 접근할 수 있음
  - 내부 슬롯은 그 함수가 존재하는 한 유지됨
- 자바스크립트의 모든 함수는 상위 스코프를 기억하므로, 이론적으로 모든 함수는 클로저다
  - 하지만, 모든 함수를 클로저라고 하지는 않음
  - 상위 스코프의 어떤 식별자도 참조하지 않는 함수는 클로저가 아니다
    - 메모리 낭비 (최적화를 통해 상위 스코프 기억하지 않음)
  - 생명 주기가 먼저 끝나도 클로저가 아님

# 24.4 클로저의 활용

- 상태를 안전하게 변경하고 유지하기 위해 사용됨
  - 은닉
  - 특정 함수에게만 상태 변경 허용
- 변수 값은 누군가에 의해 언제든지 변경될 수 있어 오류 발생의 근본적인 원인이 될 수 있음
- 함수형 프로그래밍
  - 외부 상태 변경 및 가변 데이터 지양
  - 불변성 지향
  - 클로저를 이용해 side effect 최대한 억제 가능

# 24.5 캡슐화와 정보 은닉

- 캡슐화
  - 프로퍼티와 메서드를 하나로 묶는 것
  - for 정보 은닉
    - 정보 보호
    - 객체 간 결합도 낮춤
- 객체의 모든 프로퍼티와 메서드는 기본적으로 public함
