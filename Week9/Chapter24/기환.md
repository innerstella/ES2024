# 24장 클로저

**MDN에서 정의하는 클로저**
- 클로저는 함수와 그 함수가 선언된 렉시컬 환경과의 조합이다.

## 24.1 렉시컬 스코프
### 렉시컬 스코프(정적 스코프)
자바스크립트 엔진은 함수를 어디서 호출했는지가 아니라 **함수를 어디에 정의했는지에 따라 상위 스코프를 결정**한다.
- 렉시컬 환경의 외부 렉시컬 환경에 대한 참조에 저장할 참조값을 결정한다.
- 즉, 상위 스코프에 대한 참조는 **함수 정의가 평가되는 시점**에 **함수가 정의된 환경**에 의해 결정된다.

## 24.2 함수 객체의 내부 슬롯 [[Envirionment]]
함수는 자신의 내부 슬롯 [[Envirionment]]에 자신이 정의된 환경, 즉 **상위 스코프의 참조를 저장**한다.
- [[Envirionmnet]]에 저장된 상위 스코프의 참조는 현재 실행 중인 실행 컨텍스트의 렉시컬 환경을 가리킨다.
- 함수 객체는 내부 슬롯 [[Envirionment]]에 저장한 렉시컬 환경의 참조(상위 스코프)를 자신이 존재하는 한 기억한다.

## 24.3 클로저와 렉시컬 환경
### 클로저
- 외부 함수보다 중첩 함수가 더 오래 유지되는 경우 중첩 함수는 이미 생명 주기가 종료한 외부 함수의 변수를 참조할 수 있는데, 이러한 중첩함수를 클로저라 한다.
  - 실행 컨텍스트는 생명 주기가 종료되면 스택에서 제거되지만 렉시컬 환경은 참조가 계속 되는한, 사라지지 않는다.
- 이론적으로는 자바스크립트의 모든 함수는 상위 스코프를 기억하므로 클로저다.(실제론 X)
  - 중첩 함수가 상위 스코프의 식별자를 참조하고, 중첩 함수가 외부 함수보다 오래 유지되어야함.

**자유변수** : 클로저에 의해 참조되는 상위 스코프의 변수
**-> 클로저는 자유변수에 묶여있는 함수라 할 수 있다.**

클로저가 상위 스코프를 기억을 해야 돼서 메모리 낭비라 생각할 수 있지만, **필요한 식별자만 기억하므로 메모리 낭비라 볼 수 없다.**

## 24.4 클로저의 활용
- 클로저는 상태를 안전하게 변경하고 유지하기 위해 사용한다.
- 상태를 안전하게 은닉하고 특정 함수에게만 상태 변경을 허용하기 위해 사용한다.


## 24.5 캡슐화와 정보 은닉
### 캡슐화 & 정보 은닉
- 캡슐화는 객체의 상태를 나타내는 프로퍼티와 프로퍼티를 참조하고 조작할 수 잇는 동작인 메서드를 하나로 묶는 것을 말한다.
- 정보 은닉은 객체의 특정 프로퍼티나 메서드를 감출 목적으로 캡슐화를 사용하는 것을 말한다,
  - 정보 은닉은 적절치 못한 접근으로부터 객체의 상태 변경을 방지해, 정보 보호, 객체 간의 상호의존성(결합도)를 낮추는 효과가 있다.

**자바스크립트의 정보 은닉**
- 자바스크립트는 기본적으로 **객체의 모든 프로퍼티와 메서드는 pubilc**하다.
- 자바스크립트는 정보 은닉을 **완전하게 지원하지 않는다.**
  - 인스턴스 메서드를 사용한다면 자유 변수를 통해 private를 **흉내 낼 순 있음**
  - 프로토타입 메서드를 사용하면 이마저도 불가능

## 24.6 자주 발생하는 실수
반복문에서 var 키워드로 선언한 변수는 전역 변수가 되기 때문에 원치 않는 결과가 나올 수 있다. 해결 방법은 다음과 같다.
- let, const키워드르 사용하는 반복문
  -코드 블록을 반복 실행할 때마다 새로운 렉시컬 환경을 생성하여 반복할 당시의 상태를 마치 스냅샷을 찍는 것처럼 저장한다.
    -반복문의 코드 블록 내부에서 함수를 정의할 때 의미가 있음.
    -반복문의 코드 블록 내부에 함수 정의가 없는 경우, 생성하는 새로운 렉시컬 환경은 반복 직후에 아무도 참조하지 않기 때문에 가비지 컬렉션의 대상이 된다.
- 고차 함수 사용(함수형 프로그래밍 기법)
  - 변수와 반복문의 사용을 억제할 수 있기 때문에 오류를 줄이고 가독성을 좋게 만든다.