# 40.1 이벤트 드리븐 프로그래밍

- 브라우저는 처리해야 할 특정 사건이 발생하면 이를 감지하여 이벤트를 발생시킴
- 이벤트 핸들러, 이벤트 핸들러 등록
- 이벤트 드리븐 프로그래밍 : 프로그램의 흐름을 이벤트 중심으로 제어하는 프로그래밍 방식

# 40.2 이벤트 타입

- 이벤트의 종류를 나타내는 문자열
  - 마우스 이벤트
  - 키보드 이벤트
  - 포커스 이벤트
  - 폼 이벤트
  - 값 변경 이벤트
  - DOM 뮤테이션 이벤트
  - 뷰 이벤트
  - 리소스 이벤트

# 40.3 이벤트 핸들러 등록

- 이벤트 핸들러 : 이벤트가 발생했을 때 브라우저에 호출을 위임한 함수

## 40.3.1 이벤트 핸들러 어트리뷰트 방식

- on + 이벤트 타입
  ```html
  <button onclick='console.log('Hi')'>button</button>
  ```
- 이벤트 핸들러 어트리뷰트 값으로 함수 호출문 등의 문 할당
- 이벤트 핸들러 어트리뷰트 값은 사실 암묵적으로 생성될 이벤트 핸들러의 함수 몸체를 의미함
- 그닥 좋은 방법은 아님
  - 왜냐하면 HTML과 JS가 혼재되어 있는 것은 바람직하지 않음

## 40.3.2 이벤트 핸들러 프로퍼티 방식

- 이벤트 핸들러 프로퍼티에 이벤트 핸들러를 바인딩
  ```html
  <script>
    const $button = document.querySelector("button");

    $button.onclick = function () {
      console.log("button click");
    };
  </script>
  ```
- 장점 : HTML과 JS 분리 가능
- 단점 : 이벤트 핸들러 프로퍼티에 하나의 이벤트 핸들러만 바인딩 할 수 있음

## 40.3.3 addEventListener 메서드 방식

- EventTarget.prototype.addEventListener 메서드를 사용하여 이벤트 핸들러 등록
- 타깃, 타입, 핸들러, 캡쳐링 사용 여부
- 하나 이상의 이벤트 핸들러를 등록할 수 있음
  - 등록된 순서대로 호출됨
  - 참조가 동일한 이벤트 핸들러를 중복 등록하면, 하나만 등록됨

# 40.4 이벤트 핸들러 제거

- addEventListener로 등록한 이벤트 핸들러 제거 시 사용
- 다른 방식으로 등록된 이벤트는 제거할 수 없음

# 40.5 이벤트 객체

- 이벤트가 발생하면 이벤트에 관련한 다양한 정보를 담고 있는 이벤트 객체가 동적으로 생성됨
  → 이벤트 핸들러의 첫 번째 인수로 전달됨

## 40.5.1 이벤트 객체의 상속 구조

- 이벤트가 발생하면 암묵적으로 생성되는 이벤트 객체도 생성자 함수에 의해 생성됨
- 생성된 이벤트 객체는 생성자 함수와 더불어 생성되는 프로토타입으로 구성된 프로토타입 체인의 일원이 된다
- Event 인터페이스 : DOM 내에서 발생한 이벤트에 의해 생성되는 이벤트 객체

## 40.5.2 이벤트 객체의 공통 프로퍼티

- Event 인터페이스의 이벤트 관련 프로퍼티는 모든 이벤트 객체가 상속받는 공통 프로퍼티
  - type, target, currentTarget, eventPhase, bubbles, cancelable, defaultPrevented, isTrusted, timeStamp

# 40.6 이벤트 전파

- DOM 트리 상에 존재하는 DOM 요소 노드에서 발생한 이벤트는 DOM 트리를 통해 전파됨
- 이벤트가 발생하면, 생성된 이벤트 객체는 이벤트를 발생시킨 DOM 요소인 이벤트 타깃을 중심으로 DOM 트리를 통해 전파됨
- 이벤트 객체가 전파되는 방향에 따라 3단계로 구분
  - 캡쳐링 : 상위 → 하위
  - 타깃 : 이벤트가 이벤트 타깃에 도달
  - 버블링 : 하위 → 상위
- 이벤트는 이벤트를 발생시킨 이벤트 타깃은 물론 상위 DOM 요소에서도 캐치 가능
  - 대부분의 이벤트는 캡쳐링과 버블링을 통해 전파됨

# 40.7 이벤트 위임

- 여러 개의 하위 DOM 요소에 각각 이벤트 핸들러를 등록하는 대신 하나의 상위 DOM 요소에 이벤트 핸들러를 등록하는 방법
- 주의할 점 : 상위 요소에 이벤트 핸들러를 등록하기 때문에, 이벤트를 실제로 발생시킨 DOM 요소가 개발자가 기대한 DOM 요소가 아닐 수도 있음 → 이벤트 타깃 검사 필요 (ex. Element.prototype.matches)

# 40.8 DOM 요소의 기본 동작 조작

- DOM 요소의 기본 동작 중단 : preventDevault
- 이벤트 전파 방지 : stopPropagation

# 40.9 이벤트 핸들러 내부의 this

## 40.9.1 이벤트 핸들러 어트리뷰트 방식

- 이벤트 핸들러 어트리뷰트 방식에 의해 암묵적으로 생성된 이벤트 핸들러 내부의 this는 **이벤트를 바인딩한 DOM 요소**를 가리킴

## 40.9.2 이벤트 핸들러 프로퍼티 방식과 addEventListener 메서드 방식

- 이벤트를 바인딩한 DOM 요소
  - 이벤트 핸들러 내부의 this는 이벤트 객체의 currentTarget 프로퍼티와 같음
- 화살표 함수로 정의한 이벤트 핸들러 내부의 this → 상위 스코프의 this를 가리킴
  - 화살표 함수는 함수 자체의 this 바인딩을 갖지 않음

# 40.10 이벤트 핸들러에 인수 전달

- 이벤트 핸들러 내부에서 함수를 호출하면서 인수를 전달함
- 이벤트 핸들러를 반환하는 함수를 호출하면서 인수를 전달함

# 40.11 커스텀 이벤트

## 40.11.1 커스텀 이벤트 생성

- CustomEvent 생성자 함수로 foo 이벤트 타입의 커스텀 이벤트 객체 생성
  ```jsx
  const customEvent = new CustomEvent("foo");
  ```
- 생성된 커스텀 이벤트 객체는 기본적으로
  - 버블링되지 않음 (bubbles = false)
  - preventDefault 메서드로 취소 불가 (cancelabe = false)

## 40.11.2 커스텀 이벤트 디스패치

- 생성된 커스텀 이벤트는 dispatchEvent 메서드로 디스패치(이벤트를 발생시키는 행위) 가능
- dispatchEvent 메서드에 이벤트 객체를 인수로 전달하면서 호출하면, 인수로 전달한 이벤트 타입의 이벤트가 발생함
